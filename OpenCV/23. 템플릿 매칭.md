# 템플릿 매칭

작은 크기의 부분 영상 위치를 찾아내고 싶은 경우, 주로 템플릿 매칭 기법을 사용함

- matchTemplate(image, templ, result, method, mask=noArray())
    - image : 입력 영상
    - templ : 템플릿 영상. image보다 같거나 작아야 한다.
    - result : 비교 결과 저장 행렬
    - method : 템플릿 매칭 비교 방법
    - mask : 찾고자 하는 템플릿의 마스크 영상

### 템플릿 매칭 비교 방법

- TM_SQDIFF : 제곱차 매칭 방법

- TM_CCORR : 상관관계 매칭 방법

- TM_CCOEFF : 상관계수 매칭 방법

각 방식에 _NORMED인 정규화된 버전도 있다.

이 방법들 중 정규화된 상관계수 매칭 방법이 좋은 결과를 제공한다. 그러나 연산량이 많을 수 있다.

~~~cpp
#include "opencv2/opencv.hpp"
#include <iostream>

using namespace cv;
using namespace std;

int main()
{
	Mat img = imread("test.jpg", IMREAD_COLOR);
	Mat templ = imread("templ.jpg", IMREAD_COLOR);

	if (img.empty())
	{
		cout << "image load failed" << endl;
		return 0;
	}

	img = img + Scalar(50, 50, 50); //밝기 50증가

	//가우시안 잡음 넣기
	Mat noise(img.size(), CV_32SC3);
	randn(noise, 0, 10);
	add(img, noise, img, Mat(), CV_8UC3);


	Mat res, res_norm;
	matchTemplate(img, templ, res, TM_CCOEFF_NORMED); //결과 -1~1(1일수록 가까움)
	normalize(res, res_norm, 0, 255, NORM_MINMAX, CV_8U); //0~255로 정규화

	double maxv;
	Point maxloc;
	minMaxLoc(res, 0, &maxv, 0, &maxloc);
	cout << "maxv: " << maxv << endl; //1에 가까울수록 매칭이 잘 된 것이다.

	rectangle(img, Rect(maxloc.x, maxloc.y, templ.cols, templ.rows), Scalar(0, 0, 255), 2); //네모 그리기
	
	imshow("img", img);
	imshow("templ", templ);
	imshow("res_norm", res_norm);


	waitKey(0);
	destroyAllWindows();

}

~~~

